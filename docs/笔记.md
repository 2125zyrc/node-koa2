# node+Koa后端开发
## 1.开发环境配置
* 框架/库
  * Node.js(10.15.3)
  * npm
  * Koa
  * nodemon  pm2
* 软件/工具
  * MySQL(XAMPP)
  * 微信开发者工具
  * VSCode
  * PostMan
  * Navict(数据库可视化工具)

## 2.起步
* 安装koa
```shell
yarn init -y
yarn add koa
```
* 启动node
```js
const Koa = require('koa')

const app = new Koa()

const port = 3000

app.listen(port,()=> {
  console.log(`程序启动,请访问http://localhost:${port}`);
})
```
## 3. koa
### 3.1 koa中间件
中间件的调用总会返回一个promise

调用next(),返回值是一个promise,在中间件中返回值会返回到promise中
```js
app.use(async (ctx,next)=> {
  console.log('hello word');
  let a = await next()  // 这里接收promise返回值123
  console.log(a);
  
})
app.use(()=> {
  console.log('hello word 2');
  return '123'
})
```
### 3.2 async/await
1. 异步编程的一种解决方案(终极解决方案)
2. async会将函数包装成一个peomise
3. await会阻塞当前线程,等待执行完成,拿到结果才会继续执行,异步->同步
```js
app.use(async () => {
  // console.log('hello word 2');
  const axios = require('axios')
  const start = Date.now()
  // await 阻塞当前线程
  const res = await axios.get('http://www.7yue.pro')
  const end = Date.now()
  console.log(end - start);
})
```
### 3.3 为什么一定要保证洋葱模型
[参考](https://blog.csdn.net/weixin_34187822/article/details/88875628)
1. 使用洋葱模型可以使中间件很好的进行数据传递
2. koa使用中间件,全部使用async/await可以保证洋葱模型的执行顺序不变
* 由于第二个中间件执行了异步操作,await阻塞了代码执行,所以先执行了2,等待await执行完成,再执行4
* 如果调用了第三方中间件,我们并不知道其执行顺序,也就很难保证洋葱模型执行顺序
```js
app.use( (ctx, next) => {
  console.log('1');
  next()
  console.log('2');
})
app.use(async (ctx, next) => {
  console.log('3');
  const axios = require('axios')
  // await 阻塞当前线程
  const res = await axios.get('http://www.7yue.pro')
  next()
  console.log(4);
})
// 执行顺序 1 3 2 4
```
* 所有中间件都使用async,在next()之前加await,可以保证异步编程变得像同步,也就可以保证洋葱模型的执行顺序
* 在一个中间件通过ctx变量赋值,可以使其他中间件在调用next()后(要想获取到这个值,要保证其中间件的代码全部执行完成,所以要在next()后获取其值),接收到这个中间件传递的值,
```js
app.use(async (ctx, next) => {
  console.log('1');
  await next()
  console.log(ctx.r);
  console.log('2');
})
app.use(async (ctx, next) => {
  console.log('3');
  const axios = require('axios')
  // await 阻塞当前线程
  const res = await axios.get('http://www.7yue.pro')
  ctx.r = res
  await next()
  console.log(4);
})
```
## 4. koa路由
* koa通过ctx对象获取路由信息,及返回信息操作
  * `ctx.path` 获取路由路径
  * `ctx.method` 获取请求方法
  * `ctx.body` 可以直接返回json对象
* 一个项目有很多路由,直接通过判断编写路由,项目会变得复杂不易维护,所以要引用第三方库,进行路由编写
### 4.1 koa-router
[安装第三方包](https://www.npmjs.com/package/koa-router)
```shell
yarn add koa-router
```
* 基础使用
```js
var Koa = require('koa');
var Router = require('koa-router');
 
var app = new Koa();
var router = new Router();
 
router.get('/', (ctx, next) => {
  // ctx.router available
    ctx.body = {
    key: 'classic'
  }
});
 
app
  .use(router.routes())
```
### 4.2 主题与模型划分
* web开发,好的代码的优点
  * 便于阅读
  * 利于维护
  * 提高编程效率
* 数据请求,编写路由会有很多,可以按照分类进行划分,可以根据
  * 数据类型划分
* 数据模型,有利于更好的设计数据库
### 4.3 api版本
* 为什么api要有版本
打个比方,当前路由返回的数据,
```js
{key:'classic'}
```
由于业务的变动,返回的数据会进行更改,
```js
{key: 'music'}
```
我们要考虑客户端的兼容性,一些用户会用老版本的数据,一些用户会使用新版本的数据,如果直接修改代码,可能导致老版本无法正常使用

所以很多情况下,服务器api需要兼容多个版本api,支持3个版本是比较好的,太多的话,开发维护的难度会逐渐增加
* 如何支持api版本
客户端请求路由,需要携带api版本号,携带方式有三种
1. url路由 `v1/classic/...`
2. 查询参数 `classic/?version=v1...`
3. 放入header中

* 开闭原则
  * 修改代码时存在风险的,尽量单独对原有代码进行扩展
  * 我们在编写代码时,对代码的修改是关闭的,对代码的扩展是开放的
### 4.4 实现路由自动注册require-directory
[官网介绍](https://www.npmjs.com/package/require-directory)
```js
const Router = require('koa-router')
const requireDirectory = require('require-directory')
// 导入路径的所有模块
const modules = requireDirectory(module, './api', {
  visit: whenLoadModule
})
// 每当导入一个模块就会执行这个函数
function whenLoadModule(obj) {
  // 判断当前模块是否是路由模块
  if (obj instanceof Router) {
    app.use(obj.routes())
  }
}
```
## 5. nodemon自动重启server
* 全局安装nodemon
```shell
npm i -g nodemon
```
* 启动服务
```shell
nodemon app.js
```
* 编写scripts脚本
```package.json
  "scripts": {
    "start": "nodemon app.js"
  },
```
执行`yarn start`启动服务
### 5.1vscode配置nodemon调试
* 既想通过断点调试,又想通过nodemon重启服务,配置.vscode
* 配置vscode,点击侧边栏爬虫按钮-->点击下拉小箭头-->添加配置
```json
// .vscode/launch.json

{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "nodemon",
      "runtimeExecutable": "nodemon",
      "program": "${workspaceFolder}/app.js",
      "restart": true,
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "启动程序",
      "program": "${workspaceFolder}\\app.js"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "当前文件",
      "program": "${file}" // 当前文件
    }
  ]
}

```
在小爬虫选择调试方式时,选择nodemon即可兼容调试和自动重启


## 6. 初始化管理器
分离app.js文件代码
-- core 公共方法/类
```js
// core/init.js
const requireDirectory = require('require-directory')
const Router = require('koa-router')


class InitManager {
  static initCore(app) {
    // 入口方法
    // InitManager.initLoadRouters(app)
    InitManager.app = app
    InitManager.initLoadRouters()
  }
  // 初始化路由
  static initLoadRouters() {
    // 导入路径的所有模块
    const apiDir = `${process.cwd()}/app/api`;
    requireDirectory(module, apiDir, { visit: whenLoadModule })
    // 每当导入一个模块就会执行这个函数
    function whenLoadModule(obj) {
      // 判断自动加载的模块是否为路由类型
      if (obj instanceof Router) {
        InitManager.app.use(obj.routes())
      }
    }
  }
}

module.exports = InitManager
```
```js
// app.js
const Koa = require('koa')
// 引入初始化管理器
const InitManger = require('./core/init')

const app = new Koa()
InitManger.initCore(app)

const port = 3000  //端口号

app.listen(port, () => {
  console.log(`程序启动,请访问http://localhost:${port}`);
})
```