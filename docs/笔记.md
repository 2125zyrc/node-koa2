# node+Koa后端开发
## 1.开发环境配置
* 框架/库
  * Node.js(10.15.3)
  * npm
  * Koa
  * nodemon  pm2
* 软件/工具
  * MySQL(XAMPP)
  * 微信开发者工具
  * VSCode
  * PostMan
  * Navict(数据库可视化工具)

## 2.起步
* 安装koa
```shell
yarn init -y
yarn add koa
```
* 启动node
```js
const Koa = require('koa')

const app = new Koa()

const port = 3000

app.listen(port,()=> {
  console.log(`程序启动,请访问http://localhost:${port}`);
})
```
## 3. koa
### 3.1 koa中间件
中间件的调用总会返回一个promise

调用next(),返回值是一个promise,在中间件中返回值会返回到promise中
```js
app.use(async (ctx,next)=> {
  console.log('hello word');
  let a = await next()  // 这里接收promise返回值123
  console.log(a);
  
})
app.use(()=> {
  console.log('hello word 2');
  return '123'
})
```
### 3.2 async/await
1. 异步编程的一种解决方案(终极解决方案)
2. async会将函数包装成一个peomise
3. await会阻塞当前线程,等待执行完成,拿到结果才会继续执行,异步->同步
```js
app.use(async () => {
  // console.log('hello word 2');
  const axios = require('axios')
  const start = Date.now()
  // await 阻塞当前线程
  const res = await axios.get('http://www.7yue.pro')
  const end = Date.now()
  console.log(end - start);
})
```
### 3.3 为什么一定要保证洋葱模型
[参考](https://blog.csdn.net/weixin_34187822/article/details/88875628)
1. 使用洋葱模型可以使中间件很好的进行数据传递
2. koa使用中间件,全部使用async/await可以保证洋葱模型的执行顺序不变
* 由于第二个中间件执行了异步操作,await阻塞了代码执行,所以先执行了2,等待await执行完成,再执行4
* 如果调用了第三方中间件,我们并不知道其执行顺序,也就很难保证洋葱模型执行顺序
```js
app.use( (ctx, next) => {
  console.log('1');
  next()
  console.log('2');
})
app.use(async (ctx, next) => {
  console.log('3');
  const axios = require('axios')
  // await 阻塞当前线程
  const res = await axios.get('http://www.7yue.pro')
  next()
  console.log(4);
})
// 执行顺序 1 3 2 4
```
* 所有中间件都使用async,在next()之前加await,可以保证异步编程变得像同步,也就可以保证洋葱模型的执行顺序
* 在一个中间件通过ctx变量赋值,可以使其他中间件在调用next()后(要想获取到这个值,要保证其中间件的代码全部执行完成,所以要在next()后获取其值),接收到这个中间件传递的值,
```js
app.use(async (ctx, next) => {
  console.log('1');
  await next()
  console.log(ctx.r);
  console.log('2');
})
app.use(async (ctx, next) => {
  console.log('3');
  const axios = require('axios')
  // await 阻塞当前线程
  const res = await axios.get('http://www.7yue.pro')
  ctx.r = res
  await next()
  console.log(4);
})
```
## 4. koa路由
* koa通过ctx对象获取路由信息,及返回信息操作
  * `ctx.path` 获取路由路径
  * `ctx.method` 获取请求方法
  * `ctx.body` 可以直接返回json对象
* 一个项目有很多路由,直接通过判断编写路由,项目会变得复杂不易维护,所以要引用第三方库,进行路由编写
### 4.1 koa-router
[安装第三方包](https://www.npmjs.com/package/koa-router)
```shell
yarn add koa-router
```
* 基础使用
```js
var Koa = require('koa');
var Router = require('koa-router');
 
var app = new Koa();
var router = new Router();
 
router.get('/', (ctx, next) => {
  // ctx.router available
    ctx.body = {
    key: 'classic'
  }
});
 
app
  .use(router.routes())
```
### 4.2 主题与模型划分
* web开发,好的代码的优点
  * 便于阅读
  * 利于维护
  * 提高编程效率
* 数据请求,编写路由会有很多,可以按照分类进行划分,可以根据
  * 数据类型划分
* 数据模型,有利于更好的设计数据库
### 4.3 api版本
* 为什么api要有版本
打个比方,当前路由返回的数据,
```js
{key:'classic'}
```
由于业务的变动,返回的数据会进行更改,
```js
{key: 'music'}
```
我们要考虑客户端的兼容性,一些用户会用老版本的数据,一些用户会使用新版本的数据,如果直接修改代码,可能导致老版本无法正常使用

所以很多情况下,服务器api需要兼容多个版本api,支持3个版本是比较好的,太多的话,开发维护的难度会逐渐增加
* 如何支持api版本
客户端请求路由,需要携带api版本号,携带方式有三种
1. url路由 `v1/classic/...`
2. 查询参数 `classic/?version=v1...`
3. 放入header中

* 开闭原则
  * 修改代码时存在风险的,尽量单独对原有代码进行扩展
  * 我们在编写代码时,对代码的修改是关闭的,对代码的扩展是开放的
### 4.4 实现路由自动注册require-directory
[官网介绍](https://www.npmjs.com/package/require-directory)
```js
const Router = require('koa-router')
const requireDirectory = require('require-directory')
// 导入路径的所有模块
const modules = requireDirectory(module, './api', {
  visit: whenLoadModule
})
// 每当导入一个模块就会执行这个函数
function whenLoadModule(obj) {
  // 判断当前模块是否是路由模块
  if (obj instanceof Router) {
    app.use(obj.routes())
  }
}
```
## 5. nodemon自动重启server
* 全局安装nodemon
```shell
npm i -g nodemon
```
* 启动服务
```shell
nodemon app.js
```
* 编写scripts脚本
```package.json
  "scripts": {
    "start": "nodemon app.js"
  },
```
执行`yarn start`启动服务
### 5.1vscode配置nodemon调试
* 既想通过断点调试,又想通过nodemon重启服务,配置.vscode
* 配置vscode,点击侧边栏爬虫按钮-->点击下拉小箭头-->添加配置
```json
// .vscode/launch.json

{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "nodemon",
      "runtimeExecutable": "nodemon",
      "program": "${workspaceFolder}/app.js",
      "restart": true,
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "启动程序",
      "program": "${workspaceFolder}\\app.js"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "当前文件",
      "program": "${file}" // 当前文件
    }
  ]
}

```
在小爬虫选择调试方式时,选择nodemon即可兼容调试和自动重启


## 6. 初始化管理器
分离app.js文件代码
-- core 公共方法/类
```js
// core/init.js
const requireDirectory = require('require-directory')
const Router = require('koa-router')


class InitManager {
  static initCore(app) {
    // 入口方法
    // InitManager.initLoadRouters(app)
    InitManager.app = app
    InitManager.initLoadRouters()
  }
  // 初始化路由
  static initLoadRouters() {
    // 导入路径的所有模块
    const apiDir = `${process.cwd()}/app/api`;
    requireDirectory(module, apiDir, { visit: whenLoadModule })
    // 每当导入一个模块就会执行这个函数
    function whenLoadModule(obj) {
      // 判断自动加载的模块是否为路由类型
      if (obj instanceof Router) {
        InitManager.app.use(obj.routes())
      }
    }
  }
}

module.exports = InitManager
```
```js
// app.js
const Koa = require('koa')
// 引入初始化管理器
const InitManager = require('./core/init')

const app = new Koa()
InitManager.initCore(app)

const port = 3000  //端口号

app.listen(port, () => {
  console.log(`程序启动,请访问http://localhost:${port}`);
})
```

## 7. 获取参数与linValidator校验器
向服务器传递参数方式
1. url路径传参(params)
2. ?后面进行传参(query)
3. header进行传参
4. body进行传参
### 7.1通过`koa-bodyparser`中间件获取body参数
[官网](https://www.npmjs.com/package/koa-bodyparser)
```js
// app.js
const parser = require('koa-bodyparser')
app.use(parser())
```
```js
// -app/api/classic.js
const Router = require('koa-router')
const router = new Router()

router.post('/v1/classic/latest/:id', (ctx, next) => {
  const path = ctx.params
  const query = ctx.query
  const headers = ctx.header
  const body = ctx.request.body
  
  ctx.body = {
    key: 'classic'
  }
})
module.exports = router
```
### 7.2校验参数
1. 校验出不合法参数,返回给客户端
2. 某些参数的必填项
3. 参数要符合规范(比如:手机号,email...)
校验参数有重要的两点:
1. 防止非法参数
2. 要给客户端明确的提示

## 8. 异常理论与异常处理
### 8.1 异常理论
1. 为什么要进行异常处理
告诉用户,或自己排查错误时,需要判断异常,查找错误
2. 函数执行时会发生的情况
  * 无异常,正确返回结果
  * 发生了异常
3. 根据函数设计[《代码大全2》](https://book.douban.com/subject/1477390/),判断异常方式
  * return false/null  (此方式会导致函数调用时丢失异常)
  * throw new Error  (此方式由于函数调用太多,所有函数都进行处理会使代码变复杂)
  * 全局异常处理,创建一种机制,监听任何异常
### 8.2 异步异常处理
* 将函数变成promise
* 如果某一个函数返回的是promise
* 使用async/await简化函数调用链条
* 如果函数调用链中返回promise,调用链中其他函数都使用async/await调用函数
```js
function f1() {
  f2()
}
async function f2() {
  try {
    await f3()
  } catch (error) {
    console.log('error');

  }
}
function f3() {
  return new Promise((resolve, reject) => {
    // 将异步函数包装成promise
    setTimeout(() => {
      reject('err')
    })
  })
  /* return await setTimeout(() => {
    throw new Error('err')
  }); */
}
f1()
```
### 8.3 编写全局异常处理中间件
面向切面编程
```js
// middlewares/exception.js
const catchError = async (ctx, next) => {
  try {
    await next()
  } catch (error) {
    ctx.body = '服务器有点问题,请等待...'
  }
}

module.exports = catchError
```
### 8.4 处理异常信息编写
1. 输出的错误error,要简化清晰明了的把信息传给前端
2. 返回给前端的信息有以下:
  *  message
  *  error_code 详细,开发者自己定义的 10001 20003
  *  request_url 当前请求的url
3. 处理异常错误分为两种
* 已知型错误
  * 参数校验错误
  * 明确处理错误
  * try catch
* 未知型错误  
  * 程序潜在的错误,无意识的,根本就不知道他出错了
  * 连接数据库时,账号密码输错了
```js
// middlewares/exception.js
const catchError = async (ctx, next) => {
  try {
    await next()
  } catch (error) {
    if(error.errorCode) {
      ctx.body = {
        msg: error.message,
        error_code: error.errorCode,
        request_url: error.requestUrl
      },
      ctx.status = error.status
    }
    /**
     * error 堆栈调用信息
     * error 简化清晰明了的信息,给前端
     * Http Status Code 2xx,4xx,5xx
     **返回的信息
     *  message
     *  error_code 详细,开发者自己定义的 10001 20003
     *  request_url 当前请求的url
     **错误类型
     *  *已知型错误
     *    参数校验错误
     *    明确处理错误
     *    try catch
     *  *未知型错误  
     *    程序潜在的错误,无意识的,根本就不知道他出错了
     *    连接数据库时,账号密码输错了
     */
  }
}

module.exports = catchError
```
```js
// 使用
  if (true) {
    const error = new Error('为什么错误')
    error.errorCode = 10001
    error.status = 400
    error.requestUrl = `${ctx.method} ${ctx.path}`
    throw error
  }
```
### 8.5 定义HttpException基类
处理异常信息编写,返回给前台的信息,每次都是返回固定的几个参数,我们可以封装一个继承原生js的Error的处理http异常的类,来简化我们的代码
```js
// core/http-exception.js
class HttpException extends Error {
  constructor(msg = "服务器异常", errorCode = 10000, status = 400) {
    super()
    this.errorCode = errorCode
    this.status = status
    this.msg = msg
  }
}

module.exports = {
  HttpException
}
```
调用
```js
// middlewares/exception.js
if(error instanceof HttpException) {
      ctx.body = {
        msg: error.message,
        error_code: error.errorCode,
        request: `${ctx.method} ${ctx.path}`
      },
      ctx.status = error.status
    }
```
### 8.6 扩展异常基类与global全局变量
继承基类,扩展特定的异常类
```js
class ParameterException extends HttpException {
  constructor(msg, errorCode) {
    super()
    this.code = 400
    this.msg = msg || "参数错误"
    this.errorCode = errorCode || 10000
  }
}

class NotFound extends HttpException {
  constructor(msg, errorCode) {
    super()
    this.code = 404
    this.msg = msg || "资源未找到"
    this.errorCode = errorCode || 10000
  }
}
```
每次调都要先引用对应的类,我们可以使用全局变量,在应用初始化时就加载异常类,供全局调用
```js
  //* 初始化核心方法
  static initCore(app) {
    // 入口方法
    InitManager.app = app
    InitManager.initLoadRouters()
    InitManager.loadHttpException()
  }
  //* global加载异常处理方法
  static loadHttpException() {
    const errors = require('./http-exception')
    global.errs = errors
  }
```
使用
```js
const error = new global.errs.ParameterException()
```